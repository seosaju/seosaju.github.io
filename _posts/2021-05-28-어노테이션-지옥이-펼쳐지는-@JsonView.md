---
layout: post
title: "어노테이션 지옥이 펼쳐지는 @JsonView"
tags: [Java, Spring]
comments: true
---


 작년 11월 말에 입사해서, 현재는 자회사에서 Spring을 사용하여 RESTful API를 개발하고 있다. 다뤄본 웹 애플리케이션 프레임워크라고는 django밖에 없는 나로서는 맨 땅에 헤딩 중인 상태에서 API를 하나 개발해달라는 요청이 왔다.

> 사용자가 관리하는 애완동물에 대한 정보를 건네주는 API 하나 만들어주세요!

petAccount 테이블에서 사용자의 ID와 매칭되는 레코드를 불러와 여기서 애완동물의 ID만 추출한 후, 이 ID를 애완동물의 정보로 만들어진 뷰에 매칭시키면 각 애완동물의 정보를 건네줄 수 있다.

```java
public List<PetInfoView> findByAccountId(String accountId) {
  Specification petAccountSpecification = 
    PetAccountSpecification.accountId("A." + accountId.replace("A.", ""))
          .and(PetAccountSpecification.deleted(false));
  List<PetAccount> petAccountList = petAccountRepository.findAll(petAccountSpecification);

  /*
      존재하지 않는 계정 예외처리
   */
  if (petAccountList.isEmpty()) {
      throw new ResourceNotExistException("삭제되었거나 존재하지 않는 계정 아이디입니다. AccountId: " + accountId);
  }

  /*
      사용자 ID로 조회된 펫 ID를 리스트에 저장
   */
  List<String> petIdList = new ArrayList<>();
  for (PetAccount petAccount:petAccountList) {
      petIdList.add(petAccount.getPk().getPetId());
  }

  /*
     펫 ID 리스트에 있는 각각의 펫 ID에 대한 PetInfoView 객체 리스트에 저장
   */
  Specification petSpecification = PetInfoViewSpecification.list(petIdList);
  List<PetInfoView> petInfoViewList = petInfoViewRepository.findAll(petSpecification);

  /*
      PetAccount 테이블에만 존재하고, PetInfoView 뷰에 존재하지 않는 petId일 경우 예외 처리
   */
  if (petInfoViewList.isEmpty()) {
      throw new ResourceNotExistException("계정에 등록된 펫이 없습니다. AccountId: " + accountId);
  }

  return petInfoViewList;
}
```

다만, findAll이 Spring Data JPA를 사용하여 구현된 메소드라서 petInfoView 도메인에 있는 getter를 모두 가져다 쓰는 것이었다. 

```json
{
  "petId": "PT.1703",
  "gender": "M",
  "type": "DOG",
  "name": "초초코",
  "birthday": 1609513200000,
  "registrationNumber": null,
  "nickname": "초초코코",
  "furColor": "WHITE",
  "death": false,
  "deathDay": null,
  "breedId": "PB.101",
  "breedName": "보르조이",
  "weightClass": "L",
  "specificType": null,
  "photo": "PT.1703/cP72RVJ24",
  "nature": "톨스토이의 사랑받는",
  "strAgeNo": "4",
  "strAgeName": "개월",
  "age": 0,
  "strAge": "4개월",
  "ageRange": "PUPPY",
  "adult": false
}
```

> 저기서 몇몇 컬럼들은 빼주시고 전달해주실 수 있으신가요?

 굉장히 부끄러운 코드라서 따로 저장은 안했지만, 저 문제를 해결하기 위해서 다음과 같은 과정을 수행했다.

1. petInfoViewList를 받아온다.
2. List에 있는 각각의 petInfoView를 ObjectMapper를 사용해 Map<String, Object> 타입으로 바꾼다.
3. Map의 remove 함수를 이용해 제외해야할 컬럼들을 제외한다. (...)

이 과정을 거쳤더니 결과는 만족스럽지만, 코드가 개판 5분 전으로 바뀌었다. @JsonIgnoreProperties를 사용하여 이 문제를 해결할 수도 있었지만, PetInfoView가 또 어디에 사용될지도 모르는데 이 과정을 위해서 저 방법을 사용하기엔 처음 했던 방법보다 더 끔찍해서 사용하지 않았다.

> @JsonView는 어때?

더 나은 방법이 있을 수도 있지만, 현 상황에서 사용할 수 있는 가장 좋은 방법이었다. @JsonView를 사용하면 하나의 POJO 오브젝트에서 서로 다른 프로퍼티가 조합된 JSON 문자열을 만들 수 있다는 것이다. https://jsonobject.tistory.com/398

```java
public class PetView {
    public interface PetList {}
    public interface PetListDetail extends PetList {}
}
```

```java
@Entity
@Table(catalog = "Medicals", name = "petInfoView")
public class PetInfoView {

    @Id
    @JsonView(PetView.PetList.class)
    private String petId;

    @Enumerated(EnumType.STRING)
    @JsonView(PetView.PetList.class)
    private Gender gender;

    @Enumerated(EnumType.STRING)
    @JsonView(PetView.PetList.class)
    private PetType type;

    @JsonView(PetView.PetList.class)
    private String name;
  
    @Temporal(TemporalType.TIMESTAMP)
    @JsonView(PetView.PetList.class)
    private Date birthday; // 출생일

    @Column(length = 20)
    @JsonView(PetView.PetListDetail.class)
    private String registrationNumber; // 동물등록번호
    
  .
  .
  .
    
}
```

__그리고 이 포스트의 제목인, 어노테이션 지옥이 펼쳐지게 된 것을 두 눈으로 지켜보게 되었다.__ 

@JsonView의 가장 큰 단점이라면, 따로 어노테이션을 지정해주지 않은 프로퍼티에 대해서는 공통으로 사용된다는 것이었다. 처음에 사용할 때는 PetList 인터페이스 하나만 만들고, 따로 사용할 프로퍼티에 대해서만 어노테이션을 지정했는데 사용하지 않을 프로퍼티에는 다른 클래스를 지정해야 한다.

그러다보니, PetList를 상속 받는 PetListDetail이라는 인터페이스가 하나 더 만들어지고... 위 코드처럼 JsonView가 덕지덕지 붙어있는걸 보게 됐다.

> 그래도... 차라리 도메인이 더러워지는게 낫지...

```json
{
  "petId": "PT.1509",
  "gender": "F",
  "type": "DOG",
  "name": "퐁퐁티e",
  "birthday": -62135802000000,
  "nickname": "데이터가 안쌓여",
  "death": false,
  "breedId": "PB.331",
  "breedName": "포메라니안",
  "photo": "사진 URL",
  "weight": 0.3699,
  "nature": "우리 오래 함께하자",
  "age": 2020,
  "adult": true
}
```

서비스, 컨트롤러쪽 코드를 살리고 도메인쪽 코드를 박살낸 결과 치곤 꽤 괜찮게 나왔다! 제일 걱정했던 Response Time도 만족스러울 정도로 나왔다! 분명 더 좋은 방법이 있겠지만 무식하게 코드를 짜는 것보다는 이게 훨씬 낫겠지...
